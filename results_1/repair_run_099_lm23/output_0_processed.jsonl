{"model_name_or_path": "agentless", "instance_id": "pytest-dev__pytest-5227", "model_patch": "diff --git a/testing/logging/test_reporting.py b/testing/logging/test_reporting.py\nindex 82f0458..1e19937 100644\n--- a/testing/logging/test_reporting.py\n+++ b/testing/logging/test_reporting.py\n@@ -257,6 +257,33 @@ def test_log_cli_enabled_disabled(testdir, enabled):\n \n \n def test_log_cli_default_level(testdir):\n+    # Test to ensure the logging format includes the module name\n+    testdir.makepyfile(\n+        \"\"\"\n+        import logging\n+        def test_log_format():\n+            logger = logging.getLogger(__name__)\n+            logger.warning(\"Test message\")\n+    \"\"\"\n+    )\n+    testdir.makeini(\n+        \"\"\"\n+        [pytest]\n+        log_cli=true\n+        log_cli_format = %(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\n+    \"\"\"\n+    )\n+\n+    result = testdir.runpytest()\n+\n+    # Check if the log output includes the module name\n+    result.stdout.fnmatch_lines(\n+        [\n+            \"*test_log_format.py*test_log_format*WARNING*test_log_format.py*Test message*\",\n+        ]\n+    )\n+    assert \"Test message\" in result.stdout.str()\n+    assert result.ret == 0\n     # Default log file level\n     testdir.makepyfile(\n         \"\"\"\n", "raw_model_patch": "diff --git a/testing/logging/test_reporting.py b/testing/logging/test_reporting.py\nindex 82f0458..1e19937 100644\n--- a/testing/logging/test_reporting.py\n+++ b/testing/logging/test_reporting.py\n@@ -257,6 +257,33 @@ def test_log_cli_enabled_disabled(testdir, enabled):\n \n \n def test_log_cli_default_level(testdir):\n+    # Test to ensure the logging format includes the module name\n+    testdir.makepyfile(\n+        \"\"\"\n+        import logging\n+        def test_log_format():\n+            logger = logging.getLogger(__name__)\n+            logger.warning(\"Test message\")\n+    \"\"\"\n+    )\n+    testdir.makeini(\n+        \"\"\"\n+        [pytest]\n+        log_cli=true\n+        log_cli_format = %(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\n+    \"\"\"\n+    )\n+\n+    result = testdir.runpytest()\n+\n+    # Check if the log output includes the module name\n+    result.stdout.fnmatch_lines(\n+        [\n+            \"*test_log_format.py*test_log_format*WARNING*test_log_format.py*Test message*\",\n+        ]\n+    )\n+    assert \"Test message\" in result.stdout.str()\n+    assert result.ret == 0\n     # Default log file level\n     testdir.makepyfile(\n         \"\"\"\n", "original_file_content": "# -*- coding: utf-8 -*-\nimport os\nimport re\nfrom io import open\n\nimport six\n\nimport pytest\n\n\ndef test_nothing_logged(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import sys\n\n        def test_foo():\n            sys.stdout.write('text going to stdout')\n            sys.stderr.write('text going to stderr')\n            assert False\n        \"\"\"\n    )\n    result = testdir.runpytest()\n    assert result.ret == 1\n    result.stdout.fnmatch_lines([\"*- Captured stdout call -*\", \"text going to stdout\"])\n    result.stdout.fnmatch_lines([\"*- Captured stderr call -*\", \"text going to stderr\"])\n    with pytest.raises(pytest.fail.Exception):\n        result.stdout.fnmatch_lines([\"*- Captured *log call -*\"])\n\n\ndef test_messages_logged(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import sys\n        import logging\n\n        logger = logging.getLogger(__name__)\n\n        def test_foo():\n            sys.stdout.write('text going to stdout')\n            sys.stderr.write('text going to stderr')\n            logger.info('text going to logger')\n            assert False\n        \"\"\"\n    )\n    result = testdir.runpytest(\"--log-level=INFO\")\n    assert result.ret == 1\n    result.stdout.fnmatch_lines([\"*- Captured *log call -*\", \"*text going to logger*\"])\n    result.stdout.fnmatch_lines([\"*- Captured stdout call -*\", \"text going to stdout\"])\n    result.stdout.fnmatch_lines([\"*- Captured stderr call -*\", \"text going to stderr\"])\n\n\ndef test_root_logger_affected(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n        logger = logging.getLogger()\n\n        def test_foo():\n            logger.info('info text ' + 'going to logger')\n            logger.warning('warning text ' + 'going to logger')\n            logger.error('error text ' + 'going to logger')\n\n            assert 0\n    \"\"\"\n    )\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n    result = testdir.runpytest(\"--log-level=ERROR\", \"--log-file=pytest.log\")\n    assert result.ret == 1\n\n    # The capture log calls in the stdout section only contain the\n    # logger.error msg, because of --log-level=ERROR.\n    result.stdout.fnmatch_lines([\"*error text going to logger*\"])\n    stdout = result.stdout.str()\n    assert \"warning text going to logger\" not in stdout\n    assert \"info text going to logger\" not in stdout\n\n    # The log file should contain the warning and the error log messages and\n    # not the info one, because the default level of the root logger is\n    # WARNING.\n    assert os.path.isfile(log_file)\n    with open(log_file) as rfh:\n        contents = rfh.read()\n        assert \"info text going to logger\" not in contents\n        assert \"warning text going to logger\" in contents\n        assert \"error text going to logger\" in contents\n\n\ndef test_log_cli_level_log_level_interaction(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n        logger = logging.getLogger()\n\n        def test_foo():\n            logger.debug('debug text ' + 'going to logger')\n            logger.info('info text ' + 'going to logger')\n            logger.warning('warning text ' + 'going to logger')\n            logger.error('error text ' + 'going to logger')\n            assert 0\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"--log-cli-level=INFO\", \"--log-level=ERROR\")\n    assert result.ret == 1\n\n    result.stdout.fnmatch_lines(\n        [\n            \"*-- live log call --*\",\n            \"*INFO*info text going to logger\",\n            \"*WARNING*warning text going to logger\",\n            \"*ERROR*error text going to logger\",\n            \"=* 1 failed in *=\",\n        ]\n    )\n    assert \"DEBUG\" not in result.stdout.str()\n\n\ndef test_setup_logging(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n\n        logger = logging.getLogger(__name__)\n\n        def setup_function(function):\n            logger.info('text going to logger from setup')\n\n        def test_foo():\n            logger.info('text going to logger from call')\n            assert False\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--log-level=INFO\")\n    assert result.ret == 1\n    result.stdout.fnmatch_lines(\n        [\n            \"*- Captured *log setup -*\",\n            \"*text going to logger from setup*\",\n            \"*- Captured *log call -*\",\n            \"*text going to logger from call*\",\n        ]\n    )\n\n\ndef test_teardown_logging(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n\n        logger = logging.getLogger(__name__)\n\n        def test_foo():\n            logger.info('text going to logger from call')\n\n        def teardown_function(function):\n            logger.info('text going to logger from teardown')\n            assert False\n        \"\"\"\n    )\n    result = testdir.runpytest(\"--log-level=INFO\")\n    assert result.ret == 1\n    result.stdout.fnmatch_lines(\n        [\n            \"*- Captured *log call -*\",\n            \"*text going to logger from call*\",\n            \"*- Captured *log teardown -*\",\n            \"*text going to logger from teardown*\",\n        ]\n    )\n\n\ndef test_disable_log_capturing(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import sys\n        import logging\n\n        logger = logging.getLogger(__name__)\n\n        def test_foo():\n            sys.stdout.write('text going to stdout')\n            logger.warning('catch me if you can!')\n            sys.stderr.write('text going to stderr')\n            assert False\n        \"\"\"\n    )\n    result = testdir.runpytest(\"--no-print-logs\")\n    print(result.stdout)\n    assert result.ret == 1\n    result.stdout.fnmatch_lines([\"*- Captured stdout call -*\", \"text going to stdout\"])\n    result.stdout.fnmatch_lines([\"*- Captured stderr call -*\", \"text going to stderr\"])\n    with pytest.raises(pytest.fail.Exception):\n        result.stdout.fnmatch_lines([\"*- Captured *log call -*\"])\n\n\ndef test_disable_log_capturing_ini(testdir):\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_print=False\n        \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import sys\n        import logging\n\n        logger = logging.getLogger(__name__)\n\n        def test_foo():\n            sys.stdout.write('text going to stdout')\n            logger.warning('catch me if you can!')\n            sys.stderr.write('text going to stderr')\n            assert False\n        \"\"\"\n    )\n    result = testdir.runpytest()\n    print(result.stdout)\n    assert result.ret == 1\n    result.stdout.fnmatch_lines([\"*- Captured stdout call -*\", \"text going to stdout\"])\n    result.stdout.fnmatch_lines([\"*- Captured stderr call -*\", \"text going to stderr\"])\n    with pytest.raises(pytest.fail.Exception):\n        result.stdout.fnmatch_lines([\"*- Captured *log call -*\"])\n\n\n@pytest.mark.parametrize(\"enabled\", [True, False])\ndef test_log_cli_enabled_disabled(testdir, enabled):\n    msg = \"critical message logged by test\"\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n        def test_log_cli():\n            logging.critical(\"{}\")\n    \"\"\".format(\n            msg\n        )\n    )\n    if enabled:\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            log_cli=true\n        \"\"\"\n        )\n    result = testdir.runpytest()\n    if enabled:\n        result.stdout.fnmatch_lines(\n            [\n                \"test_log_cli_enabled_disabled.py::test_log_cli \",\n                \"*-- live log call --*\",\n                \"test_log_cli_enabled_disabled.py* CRITICAL critical message logged by test\",\n                \"PASSED*\",\n            ]\n        )\n    else:\n        assert msg not in result.stdout.str()\n\n\ndef test_log_cli_default_level(testdir):\n    # Default log file level\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n        def test_log_cli(request):\n            plugin = request.config.pluginmanager.getplugin('logging-plugin')\n            assert plugin.log_cli_handler.level == logging.NOTSET\n            logging.getLogger('catchlog').info(\"INFO message won't be shown\")\n            logging.getLogger('catchlog').warning(\"WARNING message will be shown\")\n    \"\"\"\n    )\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_cli=true\n    \"\"\"\n    )\n\n    result = testdir.runpytest()\n\n    # fnmatch_lines does an assertion internally\n    result.stdout.fnmatch_lines(\n        [\n            \"test_log_cli_default_level.py::test_log_cli \",\n            \"test_log_cli_default_level.py*WARNING message will be shown*\",\n        ]\n    )\n    assert \"INFO message won't be shown\" not in result.stdout.str()\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0\n\n\ndef test_log_cli_default_level_multiple_tests(testdir, request):\n    \"\"\"Ensure we reset the first newline added by the live logger between tests\"\"\"\n    filename = request.node.name + \".py\"\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n\n        def test_log_1():\n            logging.warning(\"log message from test_log_1\")\n\n        def test_log_2():\n            logging.warning(\"log message from test_log_2\")\n    \"\"\"\n    )\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_cli=true\n    \"\"\"\n    )\n\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"{}::test_log_1 \".format(filename),\n            \"*WARNING*log message from test_log_1*\",\n            \"PASSED *50%*\",\n            \"{}::test_log_2 \".format(filename),\n            \"*WARNING*log message from test_log_2*\",\n            \"PASSED *100%*\",\n            \"=* 2 passed in *=\",\n        ]\n    )\n\n\ndef test_log_cli_default_level_sections(testdir, request):\n    \"\"\"Check that with live logging enable we are printing the correct headers during\n    start/setup/call/teardown/finish.\"\"\"\n    filename = request.node.name + \".py\"\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n        import logging\n\n        def pytest_runtest_logstart():\n            logging.warning('>>>>> START >>>>>')\n\n        def pytest_runtest_logfinish():\n            logging.warning('<<<<< END <<<<<<<')\n    \"\"\"\n    )\n\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n\n        @pytest.fixture\n        def fix(request):\n            logging.warning(\"log message from setup of {}\".format(request.node.name))\n            yield\n            logging.warning(\"log message from teardown of {}\".format(request.node.name))\n\n        def test_log_1(fix):\n            logging.warning(\"log message from test_log_1\")\n\n        def test_log_2(fix):\n            logging.warning(\"log message from test_log_2\")\n    \"\"\"\n    )\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_cli=true\n    \"\"\"\n    )\n\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"{}::test_log_1 \".format(filename),\n            \"*-- live log start --*\",\n            \"*WARNING* >>>>> START >>>>>*\",\n            \"*-- live log setup --*\",\n            \"*WARNING*log message from setup of test_log_1*\",\n            \"*-- live log call --*\",\n            \"*WARNING*log message from test_log_1*\",\n            \"PASSED *50%*\",\n            \"*-- live log teardown --*\",\n            \"*WARNING*log message from teardown of test_log_1*\",\n            \"*-- live log finish --*\",\n            \"*WARNING* <<<<< END <<<<<<<*\",\n            \"{}::test_log_2 \".format(filename),\n            \"*-- live log start --*\",\n            \"*WARNING* >>>>> START >>>>>*\",\n            \"*-- live log setup --*\",\n            \"*WARNING*log message from setup of test_log_2*\",\n            \"*-- live log call --*\",\n            \"*WARNING*log message from test_log_2*\",\n            \"PASSED *100%*\",\n            \"*-- live log teardown --*\",\n            \"*WARNING*log message from teardown of test_log_2*\",\n            \"*-- live log finish --*\",\n            \"*WARNING* <<<<< END <<<<<<<*\",\n            \"=* 2 passed in *=\",\n        ]\n    )\n\n\ndef test_live_logs_unknown_sections(testdir, request):\n    \"\"\"Check that with live logging enable we are printing the correct headers during\n    start/setup/call/teardown/finish.\"\"\"\n    filename = request.node.name + \".py\"\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n        import logging\n\n        def pytest_runtest_protocol(item, nextitem):\n            logging.warning('Unknown Section!')\n\n        def pytest_runtest_logstart():\n            logging.warning('>>>>> START >>>>>')\n\n        def pytest_runtest_logfinish():\n            logging.warning('<<<<< END <<<<<<<')\n    \"\"\"\n    )\n\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n\n        @pytest.fixture\n        def fix(request):\n            logging.warning(\"log message from setup of {}\".format(request.node.name))\n            yield\n            logging.warning(\"log message from teardown of {}\".format(request.node.name))\n\n        def test_log_1(fix):\n            logging.warning(\"log message from test_log_1\")\n\n    \"\"\"\n    )\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_cli=true\n    \"\"\"\n    )\n\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*WARNING*Unknown Section*\",\n            \"{}::test_log_1 \".format(filename),\n            \"*WARNING* >>>>> START >>>>>*\",\n            \"*-- live log setup --*\",\n            \"*WARNING*log message from setup of test_log_1*\",\n            \"*-- live log call --*\",\n            \"*WARNING*log message from test_log_1*\",\n            \"PASSED *100%*\",\n            \"*-- live log teardown --*\",\n            \"*WARNING*log message from teardown of test_log_1*\",\n            \"*WARNING* <<<<< END <<<<<<<*\",\n            \"=* 1 passed in *=\",\n        ]\n    )\n\n\ndef test_sections_single_new_line_after_test_outcome(testdir, request):\n    \"\"\"Check that only a single new line is written between log messages during\n    teardown/finish.\"\"\"\n    filename = request.node.name + \".py\"\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n        import logging\n\n        def pytest_runtest_logstart():\n            logging.warning('>>>>> START >>>>>')\n\n        def pytest_runtest_logfinish():\n            logging.warning('<<<<< END <<<<<<<')\n            logging.warning('<<<<< END <<<<<<<')\n    \"\"\"\n    )\n\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n\n        @pytest.fixture\n        def fix(request):\n            logging.warning(\"log message from setup of {}\".format(request.node.name))\n            yield\n            logging.warning(\"log message from teardown of {}\".format(request.node.name))\n            logging.warning(\"log message from teardown of {}\".format(request.node.name))\n\n        def test_log_1(fix):\n            logging.warning(\"log message from test_log_1\")\n    \"\"\"\n    )\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_cli=true\n    \"\"\"\n    )\n\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"{}::test_log_1 \".format(filename),\n            \"*-- live log start --*\",\n            \"*WARNING* >>>>> START >>>>>*\",\n            \"*-- live log setup --*\",\n            \"*WARNING*log message from setup of test_log_1*\",\n            \"*-- live log call --*\",\n            \"*WARNING*log message from test_log_1*\",\n            \"PASSED *100%*\",\n            \"*-- live log teardown --*\",\n            \"*WARNING*log message from teardown of test_log_1*\",\n            \"*-- live log finish --*\",\n            \"*WARNING* <<<<< END <<<<<<<*\",\n            \"*WARNING* <<<<< END <<<<<<<*\",\n            \"=* 1 passed in *=\",\n        ]\n    )\n    assert (\n        re.search(\n            r\"(.+)live log teardown(.+)\\n(.+)WARNING(.+)\\n(.+)WARNING(.+)\",\n            result.stdout.str(),\n            re.MULTILINE,\n        )\n        is not None\n    )\n    assert (\n        re.search(\n            r\"(.+)live log finish(.+)\\n(.+)WARNING(.+)\\n(.+)WARNING(.+)\",\n            result.stdout.str(),\n            re.MULTILINE,\n        )\n        is not None\n    )\n\n\ndef test_log_cli_level(testdir):\n    # Default log file level\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n        def test_log_cli(request):\n            plugin = request.config.pluginmanager.getplugin('logging-plugin')\n            assert plugin.log_cli_handler.level == logging.INFO\n            logging.getLogger('catchlog').debug(\"This log message won't be shown\")\n            logging.getLogger('catchlog').info(\"This log message will be shown\")\n            print('PASSED')\n    \"\"\"\n    )\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_cli=true\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"-s\", \"--log-cli-level=INFO\")\n\n    # fnmatch_lines does an assertion internally\n    result.stdout.fnmatch_lines(\n        [\n            \"test_log_cli_level.py*This log message will be shown\",\n            \"PASSED\",  # 'PASSED' on its own line because the log message prints a new line\n        ]\n    )\n    assert \"This log message won't be shown\" not in result.stdout.str()\n\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0\n\n    result = testdir.runpytest(\"-s\", \"--log-level=INFO\")\n\n    # fnmatch_lines does an assertion internally\n    result.stdout.fnmatch_lines(\n        [\n            \"test_log_cli_level.py* This log message will be shown\",\n            \"PASSED\",  # 'PASSED' on its own line because the log message prints a new line\n        ]\n    )\n    assert \"This log message won't be shown\" not in result.stdout.str()\n\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0\n\n\ndef test_log_cli_ini_level(testdir):\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_cli=true\n        log_cli_level = INFO\n        \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n        def test_log_cli(request):\n            plugin = request.config.pluginmanager.getplugin('logging-plugin')\n            assert plugin.log_cli_handler.level == logging.INFO\n            logging.getLogger('catchlog').debug(\"This log message won't be shown\")\n            logging.getLogger('catchlog').info(\"This log message will be shown\")\n            print('PASSED')\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"-s\")\n\n    # fnmatch_lines does an assertion internally\n    result.stdout.fnmatch_lines(\n        [\n            \"test_log_cli_ini_level.py* This log message will be shown\",\n            \"PASSED\",  # 'PASSED' on its own line because the log message prints a new line\n        ]\n    )\n    assert \"This log message won't be shown\" not in result.stdout.str()\n\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0\n\n\n@pytest.mark.parametrize(\n    \"cli_args\",\n    [\"\", \"--log-level=WARNING\", \"--log-file-level=WARNING\", \"--log-cli-level=WARNING\"],\n)\ndef test_log_cli_auto_enable(testdir, request, cli_args):\n    \"\"\"Check that live logs are enabled if --log-level or --log-cli-level is passed on the CLI.\n    It should not be auto enabled if the same configs are set on the INI file.\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n\n        def test_log_1():\n            logging.info(\"log message from test_log_1 not to be shown\")\n            logging.warning(\"log message from test_log_1\")\n\n    \"\"\"\n    )\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_level=INFO\n        log_cli_level=INFO\n    \"\"\"\n    )\n\n    result = testdir.runpytest(cli_args)\n    stdout = result.stdout.str()\n    if cli_args == \"--log-cli-level=WARNING\":\n        result.stdout.fnmatch_lines(\n            [\n                \"*::test_log_1 \",\n                \"*-- live log call --*\",\n                \"*WARNING*log message from test_log_1*\",\n                \"PASSED *100%*\",\n                \"=* 1 passed in *=\",\n            ]\n        )\n        assert \"INFO\" not in stdout\n    else:\n        result.stdout.fnmatch_lines(\n            [\"*test_log_cli_auto_enable*100%*\", \"=* 1 passed in *=\"]\n        )\n        assert \"INFO\" not in stdout\n        assert \"WARNING\" not in stdout\n\n\ndef test_log_file_cli(testdir):\n    # Default log file level\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n        def test_log_file(request):\n            plugin = request.config.pluginmanager.getplugin('logging-plugin')\n            assert plugin.log_file_handler.level == logging.WARNING\n            logging.getLogger('catchlog').info(\"This log message won't be shown\")\n            logging.getLogger('catchlog').warning(\"This log message will be shown\")\n            print('PASSED')\n    \"\"\"\n    )\n\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n\n    result = testdir.runpytest(\n        \"-s\", \"--log-file={}\".format(log_file), \"--log-file-level=WARNING\"\n    )\n\n    # fnmatch_lines does an assertion internally\n    result.stdout.fnmatch_lines([\"test_log_file_cli.py PASSED\"])\n\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0\n    assert os.path.isfile(log_file)\n    with open(log_file) as rfh:\n        contents = rfh.read()\n        assert \"This log message will be shown\" in contents\n        assert \"This log message won't be shown\" not in contents\n\n\ndef test_log_file_cli_level(testdir):\n    # Default log file level\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n        def test_log_file(request):\n            plugin = request.config.pluginmanager.getplugin('logging-plugin')\n            assert plugin.log_file_handler.level == logging.INFO\n            logging.getLogger('catchlog').debug(\"This log message won't be shown\")\n            logging.getLogger('catchlog').info(\"This log message will be shown\")\n            print('PASSED')\n    \"\"\"\n    )\n\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n\n    result = testdir.runpytest(\n        \"-s\", \"--log-file={}\".format(log_file), \"--log-file-level=INFO\"\n    )\n\n    # fnmatch_lines does an assertion internally\n    result.stdout.fnmatch_lines([\"test_log_file_cli_level.py PASSED\"])\n\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0\n    assert os.path.isfile(log_file)\n    with open(log_file) as rfh:\n        contents = rfh.read()\n        assert \"This log message will be shown\" in contents\n        assert \"This log message won't be shown\" not in contents\n\n\ndef test_log_level_not_changed_by_default(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n        def test_log_file():\n            assert logging.getLogger().level == logging.WARNING\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-s\")\n    result.stdout.fnmatch_lines([\"* 1 passed in *\"])\n\n\ndef test_log_file_ini(testdir):\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_file={}\n        log_file_level=WARNING\n        \"\"\".format(\n            log_file\n        )\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n        def test_log_file(request):\n            plugin = request.config.pluginmanager.getplugin('logging-plugin')\n            assert plugin.log_file_handler.level == logging.WARNING\n            logging.getLogger('catchlog').info(\"This log message won't be shown\")\n            logging.getLogger('catchlog').warning(\"This log message will be shown\")\n            print('PASSED')\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"-s\")\n\n    # fnmatch_lines does an assertion internally\n    result.stdout.fnmatch_lines([\"test_log_file_ini.py PASSED\"])\n\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0\n    assert os.path.isfile(log_file)\n    with open(log_file) as rfh:\n        contents = rfh.read()\n        assert \"This log message will be shown\" in contents\n        assert \"This log message won't be shown\" not in contents\n\n\ndef test_log_file_ini_level(testdir):\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_file={}\n        log_file_level = INFO\n        \"\"\".format(\n            log_file\n        )\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n        def test_log_file(request):\n            plugin = request.config.pluginmanager.getplugin('logging-plugin')\n            assert plugin.log_file_handler.level == logging.INFO\n            logging.getLogger('catchlog').debug(\"This log message won't be shown\")\n            logging.getLogger('catchlog').info(\"This log message will be shown\")\n            print('PASSED')\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"-s\")\n\n    # fnmatch_lines does an assertion internally\n    result.stdout.fnmatch_lines([\"test_log_file_ini_level.py PASSED\"])\n\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0\n    assert os.path.isfile(log_file)\n    with open(log_file) as rfh:\n        contents = rfh.read()\n        assert \"This log message will be shown\" in contents\n        assert \"This log message won't be shown\" not in contents\n\n\ndef test_log_file_unicode(testdir):\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_file={}\n        log_file_level = INFO\n        \"\"\".format(\n            log_file\n        )\n    )\n    testdir.makepyfile(\n        \"\"\"\n        # -*- coding: utf-8 -*-\n        from __future__ import unicode_literals\n        import logging\n\n        def test_log_file():\n            logging.getLogger('catchlog').info(\"Normal message\")\n            logging.getLogger('catchlog').info(\"\u251c\")\n            logging.getLogger('catchlog').info(\"Another normal message\")\n    \"\"\"\n    )\n\n    result = testdir.runpytest()\n\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0\n    assert os.path.isfile(log_file)\n    with open(log_file, encoding=\"utf-8\") as rfh:\n        contents = rfh.read()\n        assert \"Normal message\" in contents\n        assert u\"\u251c\" in contents\n        assert \"Another normal message\" in contents\n\n\n@pytest.mark.parametrize(\"has_capture_manager\", [True, False])\ndef test_live_logging_suspends_capture(has_capture_manager, request):\n    \"\"\"Test that capture manager is suspended when we emitting messages for live logging.\n\n    This tests the implementation calls instead of behavior because it is difficult/impossible to do it using\n    ``testdir`` facilities because they do their own capturing.\n\n    We parametrize the test to also make sure _LiveLoggingStreamHandler works correctly if no capture manager plugin\n    is installed.\n    \"\"\"\n    import logging\n    import contextlib\n    from functools import partial\n    from _pytest.logging import _LiveLoggingStreamHandler\n\n    class MockCaptureManager:\n        calls = []\n\n        @contextlib.contextmanager\n        def global_and_fixture_disabled(self):\n            self.calls.append(\"enter disabled\")\n            yield\n            self.calls.append(\"exit disabled\")\n\n    class DummyTerminal(six.StringIO):\n        def section(self, *args, **kwargs):\n            pass\n\n    out_file = DummyTerminal()\n    capture_manager = MockCaptureManager() if has_capture_manager else None\n    handler = _LiveLoggingStreamHandler(out_file, capture_manager)\n    handler.set_when(\"call\")\n\n    logger = logging.getLogger(__name__ + \".test_live_logging_suspends_capture\")\n    logger.addHandler(handler)\n    request.addfinalizer(partial(logger.removeHandler, handler))\n\n    logger.critical(\"some message\")\n    if has_capture_manager:\n        assert MockCaptureManager.calls == [\"enter disabled\", \"exit disabled\"]\n    else:\n        assert MockCaptureManager.calls == []\n    assert out_file.getvalue() == \"\\nsome message\\n\"\n\n\ndef test_collection_live_logging(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n\n        logging.getLogger().info(\"Normal message\")\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"--log-cli-level=INFO\")\n    result.stdout.fnmatch_lines(\n        [\n            \"collecting*\",\n            \"*--- live log collection ---*\",\n            \"*Normal message*\",\n            \"collected 0 items\",\n        ]\n    )\n\n\ndef test_collection_logging_to_file(testdir):\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_file={}\n        log_file_level = INFO\n        \"\"\".format(\n            log_file\n        )\n    )\n\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n\n        logging.getLogger().info(\"Normal message\")\n\n        def test_simple():\n            logging.getLogger().debug(\"debug message in test_simple\")\n            logging.getLogger().info(\"info message in test_simple\")\n    \"\"\"\n    )\n\n    result = testdir.runpytest()\n\n    assert \"--- live log collection ---\" not in result.stdout.str()\n\n    assert result.ret == 0\n    assert os.path.isfile(log_file)\n    with open(log_file, encoding=\"utf-8\") as rfh:\n        contents = rfh.read()\n        assert \"Normal message\" in contents\n        assert \"debug message in test_simple\" not in contents\n        assert \"info message in test_simple\" in contents\n\n\ndef test_log_in_hooks(testdir):\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_file={}\n        log_file_level = INFO\n        log_cli=true\n        \"\"\".format(\n            log_file\n        )\n    )\n    testdir.makeconftest(\n        \"\"\"\n        import logging\n\n        def pytest_runtestloop(session):\n            logging.info('runtestloop')\n\n        def pytest_sessionstart(session):\n            logging.info('sessionstart')\n\n        def pytest_sessionfinish(session, exitstatus):\n            logging.info('sessionfinish')\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*sessionstart*\", \"*runtestloop*\", \"*sessionfinish*\"])\n    with open(log_file) as rfh:\n        contents = rfh.read()\n        assert \"sessionstart\" in contents\n        assert \"runtestloop\" in contents\n        assert \"sessionfinish\" in contents\n\n\ndef test_log_in_runtest_logreport(testdir):\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_file={}\n        log_file_level = INFO\n        log_cli=true\n        \"\"\".format(\n            log_file\n        )\n    )\n    testdir.makeconftest(\n        \"\"\"\n        import logging\n        logger = logging.getLogger(__name__)\n\n        def pytest_runtest_logreport(report):\n            logger.info(\"logreport\")\n    \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n            def test_first():\n                assert True\n        \"\"\"\n    )\n    testdir.runpytest()\n    with open(log_file) as rfh:\n        contents = rfh.read()\n        assert contents.count(\"logreport\") == 3\n\n\ndef test_log_set_path(testdir):\n    report_dir_base = testdir.tmpdir.strpath\n\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_file_level = DEBUG\n        log_cli=true\n        \"\"\"\n    )\n    testdir.makeconftest(\n        \"\"\"\n            import os\n            import pytest\n            @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n            def pytest_runtest_setup(item):\n                config = item.config\n                logging_plugin = config.pluginmanager.get_plugin(\"logging-plugin\")\n                report_file = os.path.join({}, item._request.node.name)\n                logging_plugin.set_log_path(report_file)\n                yield\n        \"\"\".format(\n            repr(report_dir_base)\n        )\n    )\n    testdir.makepyfile(\n        \"\"\"\n            import logging\n            logger = logging.getLogger(\"testcase-logger\")\n            def test_first():\n                logger.info(\"message from test 1\")\n                assert True\n\n            def test_second():\n                logger.debug(\"message from test 2\")\n                assert True\n        \"\"\"\n    )\n    testdir.runpytest()\n    with open(os.path.join(report_dir_base, \"test_first\"), \"r\") as rfh:\n        content = rfh.read()\n        assert \"message from test 1\" in content\n\n    with open(os.path.join(report_dir_base, \"test_second\"), \"r\") as rfh:\n        content = rfh.read()\n        assert \"message from test 2\" in content"}
